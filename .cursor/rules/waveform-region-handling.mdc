---
description: 
globs: 
alwaysApply: false
---
# WaveformPlayer & Region Handling Rules

## ðŸŽµ WaveformPlayer Stability Rules

### CRITICAL: Never Re-initialize WaveSurfer
- WaveSurfer should initialize **ONCE** and remain stable throughout component lifecycle
- **NEVER** include changing props in WaveSurfer initialization useEffect dependencies
- âŒ BAD: `}, [audioUrl, peaks, canEdit, inboundRegion, isVideo, onRegionUpdate]);`
- âœ… GOOD: `}, [audioUrl, peaks, canEdit, isVideo]);`

### Use Refs for Callbacks
- Use `useRef` for callbacks that don't need to trigger re-renders
- Update refs in separate useEffect when callbacks change
```typescript
const onRegionUpdateRef = useRef(onRegionUpdate);
useEffect(() => { onRegionUpdateRef.current = onRegionUpdate; }, [onRegionUpdate]);
// Use: onRegionUpdateRef.current(data) instead of onRegionUpdate(data)
```

### Separate Event Bus Listeners by Stability
- Stable handlers (no dependencies): `region-in`, `region-play` â†’ `}, []);`
- Dynamic handlers (with dependencies): `transcription-ready` â†’ `}, [inboundRegion]);`
- Never mix stable and dynamic handlers in same useEffect

### Avoid Unnecessary Complexity
- Don't add "infinite loop prevention" flags unless absolutely necessary
- Fix root causes (like re-initialization) instead of adding workarounds
- If WaveSurfer is stable, most loop prevention becomes unnecessary

## ðŸŽ¯ Region Event Handling Rules

### CRITICAL: Prevent Infinite Loops
- **NEVER** seek on `region-in` events - this creates infinite loops
- `region-in` events should only be used for UI updates (highlighting, scrolling)
- Seeking triggers more `region-in` events, causing stack overflow

```typescript
// âŒ BAD: Creates infinite loop
regionsPlugin.on('region-in', (region) => {
  wavesurfer.seekTo(region.start / duration); // This triggers more region-in events!
});

// âœ… GOOD: Only log/update UI
regionsPlugin.on('region-in', (region) => {
  console.log('Playhead entered region:', region.id);
  // Use for UI updates only
});
```

### Event-Driven Architecture
- Follow this flow: URL â†’ `inboundRegion` â†’ `transcription-ready` â†’ `setSelectedRegion` â†’ seek
- Wait for `transcription-ready` before handling inbound regions
- Don't handle inbound regions in WaveSurfer `ready` event

### Separate User vs Automatic Events
- `region-play`: User-initiated playback (clicking region list)
- `region-in`: Automatic events (playhead entering region)
- Never auto-play on `region-in` - only seek on user actions

### Region Playback Safety
- **NEVER** use `region.play()` - causes stack overflow in WaveSurfer v7
- Always use `wavesurferRef.current.play()` after seeking
- Handle browser autoplay restrictions gracefully

```typescript
// âŒ BAD: Causes stack overflow
await region.play();

// âœ… GOOD: Seek then play main audio
const startTime = region.start;
const duration = wavesurferRef.current.getDuration();
wavesurferRef.current.seekTo(startTime / duration);
await wavesurferRef.current.play();
```

### Region Creation Validation
- Only create regions with meaningful duration: `Math.abs(region.end - region.start) > 0.01`
- Check for existing regions before creating: `!regions.find(r => r.id === region.id)`
- User drag selections always have proper duration, programmatic ones may not

### Navigation Without Refresh
- Use `navigate(newPath, { replace: true })` for region clicks
- Clear `inboundRegion` state when user clicks regions to fix play button behavior

## ðŸš« Critical Anti-Patterns to Avoid

### WaveformPlayer
- âŒ Including callback props in WaveSurfer initialization dependencies
- âŒ Re-creating WaveSurfer instance on region selection
- âŒ Using `region.play()` method (causes stack overflow)
- âŒ Seeking on `region-in` events (creates infinite loops)
- âŒ Handling inbound regions before transcription is ready
- âŒ Mixing stable and dynamic event handlers in same useEffect

### Region Management
- âŒ Auto-playing audio on automatic events
- âŒ Creating regions without duration validation
- âŒ Page refresh on region navigation
- âŒ Conflicting region click handlers (WaveformPlayer vs RegionList)

## âœ… Success Patterns

### Stable WaveformPlayer Initialization
```typescript
// Stable initialization - only essential dependencies
useEffect(() => {
  // WaveSurfer initialization
}, [audioUrl, peaks, canEdit, isVideo]);

// Separate stable event handlers
useEffect(() => {
  const handleRegionIn = (regionId) => {
    // Only UI updates, no seeking
    console.log('Playhead entered region:', regionId);
  };
  
  const handleRegionPlay = (regionId) => {
    // User-initiated play with seeking
    const region = regionsPlugin.getRegions().find(r => r.id === regionId);
    if (region) {
      wavesurfer.seekTo(region.start / wavesurfer.getDuration());
      wavesurfer.play(); // Use main audio, not region.play()
    }
  };
  
  eventBus.on('region-in', handleRegionIn);
  eventBus.on('region-play', handleRegionPlay);
  
  return () => {
    eventBus.off('region-in', handleRegionIn);
    eventBus.off('region-play', handleRegionPlay);
  };
}, []); // No dependencies - stable handlers

// Separate dynamic handlers
useEffect(() => {
  const handleTranscriptionReady = () => {
    if (inboundRegion) {
      // One-time seek to inbound region
      const region = regionsPlugin.getRegions().find(r => r.id === inboundRegion);
      if (region) {
        wavesurfer.seekTo(region.start / wavesurfer.getDuration());
      }
    }
  };
  
  eventBus.on('transcription-ready', handleTranscriptionReady);
  return () => eventBus.off('transcription-ready', handleTranscriptionReady);
}, [inboundRegion]); // Only depends on specific prop
```

### Safe Region Playback
```typescript
const playRegion = async (regionId: string) => {
  const region = regionsPlugin.getRegions().find(r => r.id === regionId);
  if (region) {
    try {
      // Seek to region start
      const startTime = region.start;
      const duration = wavesurfer.getDuration();
      wavesurfer.seekTo(startTime / duration);
      
      // Play main audio (not region.play())
      await wavesurfer.play();
    } catch (error) {
      if (error.name === 'NotAllowedError') {
        console.log('Auto-play blocked - user interaction required');
        // Just seek if play is blocked
      } else {
        console.error('Error playing region:', error);
      }
    }
  }
};
```

### Event-Driven Region Handling
```typescript
// Wait for transcription ready
eventBus.on('transcription-ready', handleInboundRegion);

// Separate user vs automatic events
eventBus.emit('region-play', regionId); // User click
eventBus.emit('region-in', regionId);   // Automatic (UI only)
```

## ðŸ”§ Debugging Tips

### Common Error Patterns
- "Maximum call stack size exceeded" â†’ Check for `region.play()` usage or infinite seeking loops
- "AbortError: play() interrupted" â†’ Media element conflicts, use main audio play
- Infinite "Seeked to region" logs â†’ Remove seeking from `region-in` handlers
- Page reloads on region click â†’ Check for unhandled promise rejections

### Prevention Strategies
- Always use main audio methods (`wavesurfer.play()`) instead of region methods
- Separate UI events (`region-in`) from user actions (`region-play`)
- Use stable event handlers with no dependencies when possible
- Handle browser autoplay restrictions gracefully
- Validate region data before operations

Remember: **Stability over complexity**. Fix root causes rather than adding workarounds.
