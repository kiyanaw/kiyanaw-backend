---
description: 
globs: 
alwaysApply: false
---
# WaveformPlayer & Region Handling Rules

## üéµ WaveformPlayer Stability Rules

### CRITICAL: Never Re-initialize WaveSurfer
- WaveSurfer should initialize **ONCE** and remain stable throughout component lifecycle
- **NEVER** include changing props in WaveSurfer initialization useEffect dependencies
- ‚ùå BAD: `}, [audioUrl, peaks, canEdit, inboundRegion, isVideo, onRegionUpdate]);`
- ‚úÖ GOOD: `}, [audioUrl, peaks, canEdit, isVideo]);`

### Use Refs for Callbacks
- Use `useRef` for callbacks that don't need to trigger re-renders
- Update refs in separate useEffect when callbacks change
```typescript
const onRegionUpdateRef = useRef(onRegionUpdate);
useEffect(() => { onRegionUpdateRef.current = onRegionUpdate; }, [onRegionUpdate]);
// Use: onRegionUpdateRef.current(data) instead of onRegionUpdate(data)
```

### Separate Event Bus Listeners by Stability
- Stable handlers (no dependencies): `region-in`, `region-play` ‚Üí `}, []);`
- Dynamic handlers (with dependencies): `transcription-ready` ‚Üí `}, [inboundRegion]);`
- Never mix stable and dynamic handlers in same useEffect

### Avoid Unnecessary Complexity
- Don't add "infinite loop prevention" flags unless absolutely necessary
- Fix root causes (like re-initialization) instead of adding workarounds
- If WaveSurfer is stable, most loop prevention becomes unnecessary

## üéØ Region Event Handling Rules

### CRITICAL: Prevent Infinite Loops
- **NEVER** seek on `region-in` events - this creates infinite loops
- `region-in` events should only be used for UI updates (highlighting, scrolling)
- Seeking triggers more `region-in` events, causing stack overflow

```typescript
// ‚ùå BAD: Creates infinite loop
regionsPlugin.on('region-in', (region) => {
  wavesurfer.seekTo(region.start / duration); // This triggers more region-in events!
});

// ‚úÖ GOOD: Only log/update UI
regionsPlugin.on('region-in', (region) => {
  console.log('Playhead entered region:', region.id);
  // Use for UI updates only
});
```

### Event-Driven Architecture
- Follow this flow: URL ‚Üí `inboundRegion` ‚Üí `transcription-ready` ‚Üí `setSelectedRegion` ‚Üí seek
- Wait for `transcription-ready` before handling inbound regions
- Don't handle inbound regions in WaveSurfer `ready` event

### Separate User vs Automatic Events
- `region-play`: User-initiated playback (clicking region list)
- `region-in`: Automatic events (playhead entering region)
- Never auto-play on `region-in` - only seek on user actions

### Region Playback Safety
- **NEVER** use `region.play()` - causes stack overflow in WaveSurfer v7
- Always use `wavesurferRef.current.play()` after seeking
- Handle browser autoplay restrictions gracefully

```typescript
// ‚ùå BAD: Causes stack overflow
await region.play();

// ‚úÖ GOOD: Seek then play main audio
const startTime = region.start;
const duration = wavesurferRef.current.getDuration();
wavesurferRef.current.seekTo(startTime / duration);
await wavesurferRef.current.play();
```

### Region Creation Validation
- Only create regions with meaningful duration: `Math.abs(region.end - region.start) > 0.01`
- Check for existing regions before creating: `!regions.find(r => r.id === region.id)`
- User drag selections always have proper duration, programmatic ones may not

### Navigation Without Refresh
- Use `navigate(newPath, { replace: true })` for region clicks
- Clear `inboundRegion` state when user clicks regions to fix play button behavior

## üö´ Critical Anti-Patterns to Avoid

### WaveformPlayer
- ‚ùå Including callback props in WaveSurfer initialization dependencies
- ‚ùå Re-creating WaveSurfer instance on region selection
- ‚ùå Using `region.play()` method (causes stack overflow)
- ‚ùå Seeking on `region-in` events (creates infinite loops)
- ‚ùå Handling inbound regions before transcription is ready
- ‚ùå Mixing stable and dynamic event handlers in same useEffect

### Region Management
- ‚ùå Auto-playing audio on automatic events
- ‚ùå Creating regions without duration validation
- ‚ùå Page refresh on region navigation
- ‚ùå Conflicting region click handlers (WaveformPlayer vs RegionList)

## ‚úÖ Success Patterns

### Stable WaveformPlayer Initialization
```typescript
// Stable initialization - only essential dependencies
useEffect(() => {
  // WaveSurfer initialization
}, [audioUrl, peaks, canEdit, isVideo]);

// Separate stable event handlers
useEffect(() => {
  const handleRegionIn = (regionId) => {
    // Only UI updates, no seeking
    console.log('Playhead entered region:', regionId);
  };
  
  const handleRegionPlay = (regionId) => {
    // User-initiated play with seeking
    const region = regionsPlugin.getRegions().find(r => r.id === regionId);
    if (region) {
      wavesurfer.seekTo(region.start / wavesurfer.getDuration());
      wavesurfer.play(); // Use main audio, not region.play()
    }
  };
  
  eventBus.on('region-in', handleRegionIn);
  eventBus.on('region-play', handleRegionPlay);
  
  return () => {
    eventBus.off('region-in', handleRegionIn);
    eventBus.off('region-play', handleRegionPlay);
  };
}, []); // No dependencies - stable handlers

// Separate dynamic handlers
useEffect(() => {
  const handleTranscriptionReady = () => {
    if (inboundRegion) {
      // One-time seek to inbound region
      const region = regionsPlugin.getRegions().find(r => r.id === inboundRegion);
      if (region) {
        wavesurfer.seekTo(region.start / wavesurfer.getDuration());
      }
    }
  };
  
  eventBus.on('transcription-ready', handleTranscriptionReady);
  return () => eventBus.off('transcription-ready', handleTranscriptionReady);
}, [inboundRegion]); // Only depends on specific prop
```

### Safe Region Playback
```typescript
const playRegion = async (regionId: string) => {
  const region = regionsPlugin.getRegions().find(r => r.id === regionId);
  if (region) {
    try {
      // Seek to region start
      const startTime = region.start;
      const duration = wavesurfer.getDuration();
      wavesurfer.seekTo(startTime / duration);
      
      // Play main audio (not region.play())
      await wavesurfer.play();
    } catch (error) {
      if (error.name === 'NotAllowedError') {
        console.log('Auto-play blocked - user interaction required');
        // Just seek if play is blocked
      } else {
        console.error('Error playing region:', error);
      }
    }
  }
};
```

### Event-Driven Region Handling
```typescript
// Wait for transcription ready
eventBus.on('transcription-ready', handleInboundRegion);

// Separate user vs automatic events
eventBus.emit('region-play', regionId); // User click
eventBus.emit('region-in', regionId);   // Automatic (UI only)
```

## üîß Debugging Tips

### Common Error Patterns
- "Maximum call stack size exceeded" ‚Üí Check for `region.play()` usage or infinite seeking loops
- "AbortError: play() interrupted" ‚Üí Media element conflicts, use main audio play
- Infinite "Seeked to region" logs ‚Üí Remove seeking from `region-in` handlers
- Page reloads on region click ‚Üí Check for unhandled promise rejections

### Prevention Strategies
- Always use main audio methods (`wavesurfer.play()`) instead of region methods
- Separate UI events (`region-in`) from user actions (`region-play`)
- Use stable event handlers with no dependencies when possible
- Handle browser autoplay restrictions gracefully
- Validate region data before operations

## üé¨ Video Synchronization Rules

### Use Media Element for Video Files
- For video files, pass the video element to WaveSurfer via the `media` option
- This ensures WaveSurfer controls the video playback directly
- The video element should be set up before WaveSurfer creation
- ‚ùå BAD: Separate video element with independent controls
- ‚úÖ GOOD: WaveSurfer managing the video element directly

```typescript
// ‚ùå BAD: Disconnected video
<video ref={videoRef} controls />
await wavesurfer.load(audioUrl);

// ‚úÖ GOOD: Connected video
// 1. Set up video element first
if (isVideo && videoRef.current) {
  videoRef.current.preload = 'auto';
}

// 2. Create WaveSurfer with media option
const wavesurfer = WaveSurfer.create({
  container: waveformRef.current,
  ...(isVideo && videoRef.current ? { media: videoRef.current } : {}),
});

// 3. Load with URL and peaks
await wavesurfer.load(audioUrl, peaks);
```

### Video Element Best Practices
- Remove `controls` attribute from video element when using with WaveSurfer
- WaveSurfer will handle all playback controls
- Video element should be positioned as an overlay/preview
- Use `playsInline` for mobile compatibility
- Set `preload="auto"` for better loading experience

Remember: **Stability over complexity**. Fix root causes rather than adding workarounds.
