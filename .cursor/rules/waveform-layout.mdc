---
description: WaveformPlayer and Layout Management Rules
globs: 
  - "src/components/player/**"
  - "src/pages/EditorPage.tsx"
  - "src/components/regions/**"
  - "src/components/layout/**"
alwaysApply: true
---

# WaveformPlayer & Layout Management Rules

## üéµ WaveformPlayer Stability Rules

### CRITICAL: Never Re-initialize WaveSurfer
- WaveSurfer should initialize **ONCE** and remain stable throughout component lifecycle
- **NEVER** include changing props in WaveSurfer initialization useEffect dependencies
- ‚ùå BAD: `}, [audioUrl, peaks, canEdit, inboundRegion, isVideo, onRegionUpdate]);`
- ‚úÖ GOOD: `}, [audioUrl, peaks, canEdit, isVideo]);`

### Use Refs for Callbacks
- Use `useRef` for callbacks that don't need to trigger re-renders
- Update refs in separate useEffect when callbacks change
```typescript
const onRegionUpdateRef = useRef(onRegionUpdate);
useEffect(() => { onRegionUpdateRef.current = onRegionUpdate; }, [onRegionUpdate]);
// Use: onRegionUpdateRef.current(data) instead of onRegionUpdate(data)
```

### Separate Event Bus Listeners by Stability
- Stable handlers (no dependencies): `region-in`, `region-play` ‚Üí `}, []);`
- Dynamic handlers (with dependencies): `transcription-ready` ‚Üí `}, [inboundRegion]);`
- Never mix stable and dynamic handlers in same useEffect

### Avoid Unnecessary Complexity
- Don't add "infinite loop prevention" flags unless absolutely necessary
- Fix root causes (like re-initialization) instead of adding workarounds
- If WaveSurfer is stable, most loop prevention becomes unnecessary

## üéØ Region Handling Rules

### Event-Driven Architecture
- Follow this flow: URL ‚Üí `inboundRegion` ‚Üí `transcription-ready` ‚Üí `setSelectedRegion` ‚Üí seek
- Wait for `transcription-ready` before handling inbound regions
- Don't handle inbound regions in WaveSurfer `ready` event

### Separate User vs Automatic Events
- `region-play`: User-initiated playback (clicking region list)
- `region-in`: Automatic events (playhead entering region)
- Never auto-play on `region-in` - only seek

### Region Creation Validation
- Only create regions with meaningful duration: `Math.abs(region.end - region.start) > 0.01`
- Check for existing regions before creating: `!regions.find(r => r.id === region.id)`
- User drag selections always have proper duration, programmatic ones may not

### Navigation Without Refresh
- Use `navigate(newPath, { replace: true })` for region clicks
- Clear `inboundRegion` state when user clicks regions to fix play button behavior

## üìê Layout Management Rules

### Container Height Strategy
- Use `h-full` for components that should fill available parent space
- Use `h-screen` only for top-level containers that should fill viewport
- ‚ùå BAD: `<EditorPage className="h-screen">` (when inside AppLayout)
- ‚úÖ GOOD: `<EditorPage className="h-full">`

### Overflow Management
- Parent containers: `overflow-hidden` to prevent page-level scrolling
- Content areas: `overflow-y-auto` only where internal scrolling is needed
- Example: RegionList content scrolls, but page doesn't scroll

### Flexbox Constraints
- Use `min-h-0` on flex items to prevent expansion beyond container
- Proper hierarchy: `AppLayout` ‚Üí `EditorPage` ‚Üí `RegionList`
- Each level should properly constrain its children

### Scrolling Behavior
- `scrollIntoView({ block: 'start' })` to position selected items at top
- Only scroll content areas, never the entire page
- Use `scrollbar-thin` utilities for custom scrollbar styling

## üö´ Anti-Patterns to Avoid

### WaveformPlayer
- ‚ùå Including callback props in WaveSurfer initialization dependencies
- ‚ùå Re-creating WaveSurfer instance on region selection
- ‚ùå Adding complex state flags without fixing root causes
- ‚ùå Handling inbound regions before transcription is ready

### Layout
- ‚ùå Using `h-screen` on nested components
- ‚ùå Allowing page-level scrolling when only content should scroll
- ‚ùå Missing `min-h-0` on flex containers
- ‚ùå Inconsistent overflow management

### Region Management
- ‚ùå Auto-playing audio on automatic events
- ‚ùå Creating regions without duration validation
- ‚ùå Page refresh on region navigation
- ‚ùå Mixing user-initiated and automatic event handling

## ‚úÖ Success Patterns

### Stable WaveformPlayer
```typescript
// Stable initialization - only essential dependencies
}, [audioUrl, peaks, canEdit, isVideo]);

// Separate stable event handlers
useEffect(() => {
  // handlers that never change
}, []);

// Separate dynamic handlers
useEffect(() => {
  // handlers that depend on specific props
}, [specificProp]);
```

### Proper Layout Hierarchy
```typescript
<AppLayout className="overflow-hidden">
  <EditorPage className="h-full">
    <RegionList className="overflow-y-auto min-h-0">
```

### Event-Driven Region Handling
```typescript
// Wait for transcription ready
eventBus.on('transcription-ready', handleInboundRegion);

// Separate user vs automatic events
eventBus.emit('region-play', regionId); // User click
eventBus.emit('region-in', regionId);   // Automatic
```

Remember: **Stability over complexity**. Fix root causes rather than adding workarounds. 