---
description: 
globs: 
alwaysApply: false
---
# Architectural Patterns

This document outlines the core architectural patterns for this application. Following these guidelines will help us build a more maintainable, testable, and performant codebase.

## 1. State Management: Server vs. Client

It's crucial to distinguish between server state and client state.

-   **Server State**: Data that is persisted remotely and fetched from an API. It involves asynchronous operations like fetching, caching, and synchronization.
-   **Client State**: Data that is ephemeral and lives only in the browser, like UI state (e.g., which modal is open) or shared state between components.

**Rule: Use TanStack Query for Server State and Zustand for Global Client State.**

### Bad Example (Mixing Concerns)

Putting server state concerns (loading, errors, data) into a client state store like Zustand.

```typescript
// src/stores/myStore.ts
import { create } from 'zustand';
import { myApi } from '../api';

interface MyState {
  data: any;
  isLoading: boolean;
  error: Error | null;
  fetchData: () => Promise<void>;
}

export const useMyStore = create<MyState>((set) => ({
  data: null,
  isLoading: false,
  error: null,
  fetchData: async () => {
    set({ isLoading: true, error: null });
    try {
      const data = await myApi.getSomeData();
      set({ data, isLoading: false });
    } catch (error) {
      set({ error, isLoading: false });
    }
  },
}));
```

### Good Example (Separating Concerns)

Using TanStack Query for server state and only putting necessary data into Zustand.

```typescript
// src/services/myService.ts
import { myApi } from '../api';

export const getMyData = async () => {
  return myApi.getSomeData();
};

// src/components/MyComponent.tsx
import { useQuery } from '@tanstack/react-query';
import { getMyData } from '../services/myService';
import { useEditorStore } from '../stores/useEditorStore';

function MyComponent() {
  const setData = useEditorStore(state => state.setData);
  const { data, isLoading, error } = useQuery({
    queryKey: ['myData'],
    queryFn: getMyData,
  });

  useEffect(() => {
    if (data) {
      // If needed, sync server data to the client store
      setData(data);
    }
  }, [data, setData]);

  // ... render component based on isLoading, error, data
}
```

## 2. The Service Layer

All data-fetching logic (whether it's `API.graphql`, DataStore, or a REST API) should be encapsulated within a "service" layer. This decouples our components and state management from the specific data-fetching implementation.

**Rule: Create dedicated service files (e.g., `src/services/transcriptionService.ts`) for all API interactions.**

### Bad Example (Fetching in a Component)

```tsx
// src/pages/EditorPage.tsx
import { DataStore } from 'aws-amplify';
import { Transcription } from '../models';

function EditorPage() {
  const [transcription, setTranscription] = useState<Transcription | null>(null);

  useEffect(() => {
    const fetchTranscription = async () => {
      const result = await DataStore.query(Transcription, 'some-id');
      setTranscription(result);
    };
    fetchTranscription();
  }, []);

  // ...
}
```

### Good Example (Using a Service)

```typescript
// src/services/transcriptionService.ts
import { DataStore } from 'aws-amplify';
import { Transcription } from '../models';

export const getTranscriptionById = async (id: string): Promise<Transcription | undefined> => {
  return DataStore.query(Transcription, id);
};

// src/pages/EditorPage.tsx
import { useQuery } from '@tanstack/react-query';
import { getTranscriptionById } from '../services/transcriptionService';

function EditorPage({ id }) {
  const { data: transcription } = useQuery({
    queryKey: ['transcription', id],
    queryFn: () => getTranscriptionById(id),
  });

  // ...
}
```

## 3. Stable Component Layouts

To prevent components from unmounting and remounting during data-fetching cycles, which can lead to loss of internal component state (like a video player's position), we must maintain a stable component layout.

**Rule: Avoid top-level conditional returns for loading/error states. Render these states within a single, stable parent layout.**

### Bad Example (Causes Unmounting)

This pattern causes the entire component tree below it to be destroyed and recreated when `isLoading` or `error` changes state.

```tsx
// src/pages/EditorPage.tsx
function EditorPage() {
  const { isLoading, error, data } = useQuery(/* ... */);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <ErrorMessage message={error.message} />;
  }

  return (
    <div>
      {/* This component and its children (like WaveformPlayer) will be unmounted */}
      <h1>{data.title}</h1>
      <WaveformPlayer src={data.source} />
    </div>
  );
}
```

### Good Example (Stable Layout)

This pattern keeps the main layout and the `WaveformPlayer` mounted at all times. It only conditionally renders the UI *inside* the stable structure.

```tsx
// src/pages/EditorPage.tsx
function EditorPage() {
  const { isLoading, error, data } = useQuery(/* ... */);

  return (
    <div className="flex flex-col h-full overflow-hidden relative">
      {/* Loading/Error Overlay */}
      {(isLoading || error) && (
        <div className="absolute-overlay">
          {isLoading && <LoadingSpinner />}
          {error && <ErrorMessage message={error.message} />}
        </div>
      )}

      {/* Main Content (always rendered) */}
      <WaveformPlayer src={data?.source} />
      <RegionList regions={data?.regions} />
    </div>
  );
}
```
